The hoops we jumped through to add some basic features to MongoMapper made me
consider that there had to be a better way.

Me: Mongo, what data types do you support?
Mongo: Any! As long as they are JSON!
Me: Way Cool!  Here have some JSON! (...clickety...click...to_json...clikety...clack...)
Mongo: Oh yea, you have a JSON string, I want the JSON as a Hash
Me: Anything else?
Mongo: Well...
Me: Yes?
Mongo: It is not really JSON.  BSON is basically JSON.  You will never notice.
Me: Alright (...clickety...click...to_bson...clikety...clack...) How about that?
Mongo: Yes, just right!

Here is what I want I would my Mongo ODM to be like.

ruby_thing = SomeRubyThing.new
...work that thing...
db.save_to_collection('collection', ruby_thing)

...later...
db.save(ruby_thing)

...even_later...
ruby_thing_reloaded = db.find_parent(some_object_within_ruby_thing)
...keep working that thing...

First, I am good with
using an attribute identifier macro, much like ActiveRecord.  So to start,
lets keep the key macro, and we will define it in a base class:

class Address < MongoDoc::Base
  key :street
  key :city
  key :state
  key :zip_code
end

Good, very similar to what we have already.  The macro for key looks
something like this:

class MongoDoc::Base
  def self.key(name)
    keys << name
  
    define_method name do
      read_attribute(name)
    end
  
    define_method "#{name}=" do |value|
      write_attribute(name, value)
    end
  end
end

We can write read_attribute and write_attribute (defined elsewhere) to
support whatever other features we need, like dirty tracking.

We are tracking our attributes, and allowing them to set in the usual
way.  Now in order to allow Mongo to save our address it will have to be JSON,
so we need to_json:

class MongoDoc::Base
  def to_json(*args)
    {'json_class' => self.class.name}.tap do |json_hash|
      self.class.keys.each do |name|
        json_hash[name] = send(name)
      end
    end.to_json(*args)
  end
end

And we also need to be able to convert it back from JSON:

class MongoDoc::Base
  def self.json_create(json_hash)
    klass = json_hash.delete('json_class')
    return json_hash unless klass
    klass.constantize.new.tap do |obj|
      json_hash.each do |name, value|
        obj.send("#{name}=", value)
      end
    end
  end
end  

Seems good.  Can we embed our Address within a Location?  Lets try:

class Location < MongoDoc::Base
  key :address
end

Yea, that will work.

And can we derive classes?

class WifiAccessible < Location
  key :network_name
end

Yup!  Still works.

Now, how do we support actually writing to MongoDB?  Simple we save the json!
We can wrap that up in a save method, so we can do this:

location.save

class MongoDoc::Base
  def save
    self.class.collection.save(to_json)
  end
end

To support reading it back, we should probably save the _id, and expose it
back as the id attribute:

class MongoDoc::Base
  key :_id
  alias :id :_id
end

returned_id = mongodb_collection_from_somewhere.save(patient.to_json)
patient._id = id

Then when to read the patient back, we can use the id and then convert back to
the object from json:

Patient.find_one(patient.id)

  def self.find_one(id)
    JSON.parse(mongodb_collection_from_somewhere.find_one(id))
  end
end

Yea, there is some magic going on here thanks to the JSON gem, the JSON
returned from the driver is magically converted into Ruby objects.

NEXT UP:

many/belongs_to and parents
mongodb collections
validations and callbacks
references
